<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jason Antman's Blog</title><link href="http://blog.jasonantman.com/" rel="alternate"></link><link href="http://blog.jasonantman.com/feeds/tags/yum.atom.xml" rel="self"></link><id>http://blog.jasonantman.com/</id><updated>2014-07-11T23:31:00-04:00</updated><entry><title>How Yum and RPM Compare Versions</title><link href="http://blog.jasonantman.com/2014/07/how-yum-and-rpm-compare-versions/" rel="alternate"></link><updated>2014-07-11T23:31:00-04:00</updated><author><name>Jason Antman</name></author><id>tag:blog.jasonantman.com,2014-07-11:2014/07/how-yum-and-rpm-compare-versions/</id><summary type="html">&lt;p&gt;I was recently tripped up by a bug in Puppet, &lt;a href="https://tickets.puppetlabs.com/browse/PUP-1244"&gt;&lt;span class="caps"&gt;PUP&lt;/span&gt;-1244&lt;/a&gt;,
dealing with how it compares package versions. All of Puppet&amp;#8217;s Package types assumed
&lt;a href="http://semver.org/"&gt;semantic versioning&lt;/a&gt;, and that&amp;#8217;s far from the case for RPMs and therefore Yum. This
manifested itself in how Puppet validates package installations - if a version was explicitly specified
and Yum/&lt;span class="caps"&gt;RPM&lt;/span&gt; could install it, puppet would shell out to them and install the package, but then report
a failure in its post-install validation, as the &lt;em&gt;exact&lt;/em&gt; version string specified isn&amp;#8217;t present.
For example, many RedHat/CentOS packages (such as those from &lt;span class="caps"&gt;EPEL&lt;/span&gt;) include a release string with the major
version of the distribution they were packged for - i.e. &amp;#8220;.el5&amp;#8221; or &amp;#8220;.el6&amp;#8221;. If Puppet was instructed to
install package &amp;#8220;foo&amp;#8221; version &amp;#8220;1.2.3&amp;#8221;, but the actual package in the repositories was &amp;#8220;foo-1.2.3-el5&amp;#8221;,
Puppet would cause the package to be installed, but then report&amp;nbsp;failure.&lt;/p&gt;
&lt;p&gt;I cut a &lt;a href="https://github.com/puppetlabs/puppet/pull/2866"&gt;pull request&lt;/a&gt; against the Puppet4 branch to
fix these issues, essentially re-implementing yum and rpm&amp;#8217;s version comparison logic in Ruby. It took
me a few days of research and sorting through source code (and in the process I found that &lt;code&gt;yum&lt;/code&gt;, despite
its use in so many distributions, has no unit tests at all) but I finally got it finished. In the process,
I found out exactly how&amp;#8230; weird&amp;#8230; &lt;span class="caps"&gt;RPM&lt;/span&gt;&amp;#8217;s version comparison rules&amp;nbsp;are.&lt;/p&gt;
&lt;h3 id="package-naming-and-parsing"&gt;Package Naming and&amp;nbsp;Parsing&lt;/h3&gt;
&lt;p&gt;&lt;span class="caps"&gt;RPM&lt;/span&gt; package names are made up of five parts; the package name, epoch, version, release, and architecture.
This format is commonly referred to as the acronym &lt;span class="caps"&gt;NEVRA&lt;/span&gt;. The epoch is not always included; it is assumed
to be zero (0) on any packages that lack it explicitly. The format for the whole string is &lt;code&gt;n-e:v-r.a&lt;/code&gt;.
For my purposes, I was only really concerned with comparing the &lt;span class="caps"&gt;EVR&lt;/span&gt; portion; Puppet knows about package names
and the bug herein was with what Puppet calls the &amp;#8220;version&amp;#8221; (&lt;span class="caps"&gt;EVR&lt;/span&gt; in yum/rpm parlance). Parsing is pretty&amp;nbsp;simple:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If there is a &lt;code&gt;:&lt;/code&gt; in the string, everything before it is the epoch. If not, the epoch is&amp;nbsp;zero.&lt;/li&gt;
&lt;li&gt;If there is a &lt;code&gt;-&lt;/code&gt; in the &lt;em&gt;remaining&lt;/em&gt; string, everything before the first &lt;code&gt;-&lt;/code&gt; is the version,
  and everything after it is the release. If there isn&amp;#8217;t one, the release is considered&amp;nbsp;null/nill/None/whatever.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="how-yum-compares-evr"&gt;How Yum Compares&amp;nbsp;&lt;span class="caps"&gt;EVR&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Once the package string is parsed into its &lt;span class="caps"&gt;EVR&lt;/span&gt; components, yum calls &lt;code&gt;rpmUtils.miscutils.compareEVR()&lt;/code&gt;,
which does some data type massaging for the inputs, and then calls out to &lt;code&gt;rpm.labelCompare()&lt;/code&gt;
(found in &lt;code&gt;rpm.git/python/header-py.c&lt;/code&gt;). &lt;code&gt;labelCompare()&lt;/code&gt; sets each epoch
to &amp;#8220;0&amp;#8221; if it was null/Nonem, and then uses &lt;code&gt;compare_values()&lt;/code&gt; to compare each &lt;span class="caps"&gt;EVR&lt;/span&gt; portion, which in turn falls through
to a function called &lt;code&gt;rpmvercmp()&lt;/code&gt; (see below). The algorithm for &lt;code&gt;labelCompare()&lt;/code&gt; is as&amp;nbsp;follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Set each epoch value to 0 if it&amp;#8217;s&amp;nbsp;null/None.&lt;/li&gt;
&lt;li&gt;Compare the epoch values using &lt;code&gt;compare_values()&lt;/code&gt;. If they&amp;#8217;re not equal, return that result, else
   move on to the next portion (version). The logic within &lt;code&gt;compare_values()&lt;/code&gt; is that if one is empty/null
   and the other is not, the non-empty one is greater, and that ends the comparison. If neither of
   them is empty/not present, compare them using &lt;code&gt;rpmvercmp()&lt;/code&gt; and follow the same logic; if one
   is &amp;#8220;greater&amp;#8221; (newer) than the other, that&amp;#8217;s the end result of the comparison. Otherwise, move
   on to the next component&amp;nbsp;(version).&lt;/li&gt;
&lt;li&gt;Compare the versions using the same&amp;nbsp;logic.&lt;/li&gt;
&lt;li&gt;Compare the releases using the same&amp;nbsp;logic.&lt;/li&gt;
&lt;li&gt;If all of the components are &amp;#8220;equal&amp;#8221;, the packages are the&amp;nbsp;same.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The real magic, obviously, happens in &lt;code&gt;rpmvercmp()&lt;/code&gt;, the rpm library function to compare two
versions (or epochs, or releases). That&amp;#8217;s also where the madness&amp;nbsp;happens.&lt;/p&gt;
&lt;h3 id="how-rpm-compares-version-parts"&gt;How &lt;span class="caps"&gt;RPM&lt;/span&gt; Compares Version&amp;nbsp;Parts&lt;/h3&gt;
&lt;p&gt;&lt;span class="caps"&gt;RPM&lt;/span&gt; is written in C. Converting all of the buffer and pointer processing for these strings
over to Ruby was quite a pain. That being said, I didn&amp;#8217;t make this up, this is actually the
algorithm that &lt;code&gt;rpmvercmp()&lt;/code&gt; (&lt;code&gt;lib/rpmvercmp.c&lt;/code&gt;) uses to compare version &amp;#8220;parts&amp;#8221;
(epoch, version, release). This function returns 0 if the strings are equal, 1 if &lt;code&gt;a&lt;/code&gt; (the
first string argument) is newer than &lt;code&gt;b&lt;/code&gt; (the second string argument), or -1 if
&lt;code&gt;a&lt;/code&gt; is older than &lt;code&gt;b&lt;/code&gt;. Also keep in mind that this uses pointers in C, so it works by removing
a sequence of 0 or more characters from the front of each string, comparing them, and then repeating
for the remaining characters in each string until something is unequal, or a string reaches its&amp;nbsp;end.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If the strings are binary equal (&lt;code&gt;a == b&lt;/code&gt;), they&amp;#8217;re equal, return&amp;nbsp;0.&lt;/li&gt;
&lt;li&gt;Loop over the strings, left-to-right.&lt;ol&gt;
&lt;li&gt;Trim anything that&amp;#8217;s not &lt;code&gt;[A-Za-z0-9]&lt;/code&gt; or tilde (&lt;code&gt;~&lt;/code&gt;) from the front of both&amp;nbsp;strings.&lt;/li&gt;
&lt;li&gt;If both strings start with a tilde, discard it and move on to the next&amp;nbsp;character.&lt;/li&gt;
&lt;li&gt;If string &lt;code&gt;a&lt;/code&gt; starts with a tilde and string &lt;code&gt;b&lt;/code&gt; does not, return -1 (string &lt;code&gt;a&lt;/code&gt; is older);
   and the inverse if string &lt;code&gt;b&lt;/code&gt; starts with a tilde and string &lt;code&gt;a&lt;/code&gt; does&amp;nbsp;not.&lt;/li&gt;
&lt;li&gt;End the loop if either string has reached zero&amp;nbsp;length.&lt;/li&gt;
&lt;li&gt;If the first character of &lt;code&gt;a&lt;/code&gt; is a digit, pop the leading chunk of continuous digits from
   each string (which may be &amp;#8221; for &lt;code&gt;b&lt;/code&gt; if only one &lt;code&gt;a&lt;/code&gt; starts with digits). If &lt;code&gt;a&lt;/code&gt; begins
   with a letter, do the same for leading&amp;nbsp;letters.&lt;/li&gt;
&lt;li&gt;If the segement from &lt;code&gt;b&lt;/code&gt; had 0 length, return 1 if the segment from &lt;code&gt;a&lt;/code&gt; was numeric, or
   -1 if it was alphabetic. The logical result of this is that if &lt;code&gt;a&lt;/code&gt; begins with numbers
   and &lt;code&gt;b&lt;/code&gt; does not, &lt;code&gt;a&lt;/code&gt; is newer (return 1). If &lt;code&gt;a&lt;/code&gt; begins with letters and &lt;code&gt;b&lt;/code&gt; does not,
   then &lt;code&gt;a&lt;/code&gt; is older (return -1). If the leading character(s) from &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; were both
   numbers or both letters, continue&amp;nbsp;on.&lt;/li&gt;
&lt;li&gt;If the leading segments were both numeric, discard any leading zeros and &lt;em&gt;whichever one is longer
   wins&lt;/em&gt;. If &lt;code&gt;a&lt;/code&gt; is longer than &lt;code&gt;b&lt;/code&gt; (without leading zeroes), return 1, and vice-versa. If
   they&amp;#8217;re of the same length, continue&amp;nbsp;on.&lt;/li&gt;
&lt;li&gt;Compare the leading segments with &lt;code&gt;strcmp()&lt;/code&gt; (or &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; in Ruby). If that returns a non-zero
   value, then return that value. Else continue to the next iteration of the&amp;nbsp;loop.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;If the loop ended (nothing has been returned yet, either both strings are totally the same or they&amp;#8217;re
   the same up to the end of one of them, like with &amp;#8220;1.2.3&amp;#8221; and &amp;#8220;1.2.3b&amp;#8221;), then the longest wins -
   if what&amp;#8217;s left of &lt;code&gt;a&lt;/code&gt; is longer than what&amp;#8217;s left of &lt;code&gt;b&lt;/code&gt;, return 1. Vice-versa for if what&amp;#8217;s
   left of &lt;code&gt;b&lt;/code&gt; is longer than what&amp;#8217;s left of &lt;code&gt;a&lt;/code&gt;. And finally, if what&amp;#8217;s left of them is the same
   length, return&amp;nbsp;0.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Well there you have it. Quite convoluted. And full of things like the &amp;#8220;~&amp;#8221; magic character (&amp;#8220;~1&amp;#8221; is always
older than&amp;nbsp;&amp;#8220;9999zzzz&amp;#8221;).&lt;/p&gt;</summary><category term="rpm"></category><category term="yum"></category><category term="puppet"></category><category term="versions"></category></entry><entry><title>Search for a small-scale but automated RPM build system</title><link href="http://blog.jasonantman.com/2013/05/search-for-a-small-scale-but-automated-rpm-build-system/" rel="alternate"></link><updated>2013-05-13T05:00:00-04:00</updated><author><name>admin</name></author><id>tag:blog.jasonantman.com,2013-05-13:2013/05/search-for-a-small-scale-but-automated-rpm-build-system/</id><summary type="html">&lt;p&gt;&lt;strong&gt;This post is part of a series of older draft posts from a few months
ago that I&amp;#8217;m just getting around to publishing. Unfortunately, I have
yet to find a build system that meets my requirements (see the last&amp;nbsp;paragraph).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;At work, we have a handful - currently a really small number - of &lt;span class="caps"&gt;RPM&lt;/span&gt;
packages that we need to build and deploy internally for our CentOS
server infrastructure. A number of them are just pulled down from
specific third-party repositories and rebuilt to have the vendor set as
us, and some are internally patched or developed software. We run
websites, and on the product side, we&amp;#8217;re a
Python/&lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; shop (in fact, probably
one of the largest Django apps out there). We don&amp;#8217;t deploy our Django
apps via &lt;span class="caps"&gt;RPM&lt;/span&gt;, so building and distributing RPMs is definitely not one of
our core competencies. In fact, we really only want to do it when we&amp;#8217;re
testing/deploying a new distro, or when an upstream package is&amp;nbsp;updated.&lt;/p&gt;
&lt;p&gt;Last week I pulled a ticket to deploy &lt;a href="http://nodejs.org/"&gt;node.js&lt;/a&gt; to
one of our build hosts, and we&amp;#8217;ve got a few things in the pipeline that
also rely on it. I found the
&lt;a href="https://github.com/puppetlabs/puppetlabs-nodejs"&gt;puppetlabs-nodejs&lt;/a&gt;
module on Github that&amp;#8217;s supposed to install it on &lt;span class="caps"&gt;RHEL&lt;/span&gt;/CentOS, but it
pulls packages from
&lt;a href="http://patches.fedorapeople.org/oldnode/stable/"&gt;http://patches.fedorapeople.org/oldnode/stable/&lt;/a&gt;,
and the newest version of nodejs there is 0.6.18, which is quite old. I
can&amp;#8217;t find any actively maintained sources of newer nodejs packages for
&lt;span class="caps"&gt;RHEL&lt;/span&gt;/CentOS (yeah, I know, that&amp;#8217;s one down side to the
distributions&amp;#8230;). However, I did find that nodejs 0.9.5 is being &lt;a href="http://koji.fedoraproject.org/koji/packageinfo?packageID=15154"&gt;built
for Fedora 18/19 in the Fedora build
system&lt;/a&gt;,
is already in the Fedora 18 Testing and Fedora Rawhide repos, but is
failing its &lt;span class="caps"&gt;EL6&lt;/span&gt; builds in their system. The decision I&amp;#8217;ve come to is to
use the puppetlabs-nodejs module to install it, but try and rebuild the
Fedora 18 RPMs under CentOS 5 and&amp;nbsp;6.&lt;/p&gt;
&lt;p&gt;So that&amp;#8217;s the background. Now, my current task: to search for an &lt;span class="caps"&gt;RPM&lt;/span&gt;
build system for my current job. My core requirements, in no specific
order,&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Be relatively easy and quick to use for people who have a specfile
    or &lt;span class="caps"&gt;SRPM&lt;/span&gt; and want to be able to &amp;#8220;ensure =&gt; present&amp;#8221; the finished &lt;span class="caps"&gt;RPM&lt;/span&gt;
    on a system. i.e., require as little per-package configuration as&amp;nbsp;possible.&lt;/li&gt;
&lt;li&gt;Be able to handle rebuilding &amp;#8220;all&amp;#8221; of our RPMs when we roll out a
    new distro version. Doesn&amp;#8217;t necessarily need to be automatic, but
    should be relatively&amp;nbsp;simple.&lt;/li&gt;
&lt;li&gt;Ideally, not need to be running constantly - i.e. something that
    will cope well with build hosts being VMs that are shut down when
    they&amp;#8217;re not&amp;nbsp;needed.&lt;/li&gt;
&lt;li&gt;Handle automatically putting successfully built packages into a
    repository, ideally with some sort of (manual) promotion process
    from staging to&amp;nbsp;stable.&lt;/li&gt;
&lt;li&gt;Have minimal external (infrastructure) dependencies that we can&amp;#8217;t
    satisfy with existing&amp;nbsp;systems.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, the first step was to research existing &lt;span class="caps"&gt;RPM&lt;/span&gt; build systems and how
others do this. Here&amp;#8217;s a list of what I could find online, though most
of these are from distributions and software vendors/projects, not
end-user companies that are only building for internal&amp;nbsp;use.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://fedorahosted.org/koji/wiki"&gt;Koji&lt;/a&gt; is the build system used
    by &lt;a href="http://fedoraproject.org/wiki/Koji"&gt;Fedora&lt;/a&gt; and RedHat. It&amp;#8217;s
    about as full-featured as any can be, and I&amp;#8217;m familiar with it from
    my time at &lt;a href="http://koji.rutgers.edu/koji/"&gt;Rutgers University&lt;/a&gt;, as
    it&amp;#8217;s used to maintain their CentOS/&lt;span class="caps"&gt;RHEL&lt;/span&gt; packages. It&amp;#8217;s based largely
    on Mock. However, &lt;a href="http://fedoraproject.org/wiki/Koji/ServerHowTo"&gt;setting up the build
    server&lt;/a&gt; is no
    trivial task; there are few installations outside of Fedora/RedHat,
    and it relies on either Kerberos or an &lt;span class="caps"&gt;SSL&lt;/span&gt; &lt;span class="caps"&gt;CA&lt;/span&gt; infrastructure to
    authenticate machines and clients. So, it&amp;#8217;s designed for too large a
    scale and too much infrastructure for&amp;nbsp;me.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;PLD&lt;/span&gt; Linux has a &lt;a href="https://www.pld-linux.org/developingpld/builderscript"&gt;builder
    script&lt;/a&gt; that
    seems to automate &lt;code&gt;rpmbuild&lt;/code&gt; as well as fetching sources and
    resolving/building dependencies. I haven&amp;#8217;t looked at the script yet,
    but apparently it&amp;#8217;s in &lt;span class="caps"&gt;PLD&lt;/span&gt;&amp;#8217;s &amp;#8220;rpm-build-tools&amp;#8221;&amp;nbsp;package.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;PLD&lt;/span&gt; Linux also has a &lt;span class="caps"&gt;CVS&lt;/span&gt; repository for something called
    &lt;a href="http://cvs.pld-linux.org/cgi-bin/cvsweb/pld-builder.new"&gt;pld-builder.new&lt;/a&gt;.
    The
    &lt;a href="http://cvs.pld-linux.org/cgi-bin/cvsweb/pld-builder.new/doc/README?rev=1.5"&gt;&lt;span class="caps"&gt;README&lt;/span&gt;&lt;/a&gt;
    and
    &lt;a href="http://cvs.pld-linux.org/cgi-bin/cvsweb/pld-builder.new/doc/ARCHITECTURE?rev=1.6"&gt;&lt;span class="caps"&gt;ARCHITECTURE&lt;/span&gt;&lt;/a&gt;
    files make it sound like a relatively simple mainly-Python system
    that builds &lt;span class="caps"&gt;SRPMS&lt;/span&gt; and binary packages when requested, and most
    importantly, seems like a simple system that uses little more than
    shared filesystem access for communication and&amp;nbsp;coordination.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;ALT&lt;/span&gt; Linux has &lt;a href="http://en.altlinux.org/Sisyphus"&gt;Sisyphus&lt;/a&gt;, which
    combines repository management and web interface tools, package
    building and testing tools, and&amp;nbsp;more.&lt;/li&gt;
&lt;li&gt;The Dries &lt;span class="caps"&gt;RPM&lt;/span&gt; repository uses (or at least used&amp;#8230; my reference is
    quite old) &lt;a href="http://dries.ulyssis.org/rpm/pydar2/index.html"&gt;pydar2&lt;/a&gt;,
    &amp;#8220;a distributed client/server program which allows you to build
    multiple spec files on multiple distribution/architecture
    combinations automatically.&amp;#8221; That sounds like it could be what I
    need, but the last update says that it isn&amp;#8217;t finished yet, and that
    was in &lt;strong&gt;2005&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Mandriva Linux has pretty extensive information on their build
    system &lt;a href="http://wiki.mandriva.com/en/Category:Build_System"&gt;on their
    wiki&lt;/a&gt; and a
    &lt;a href="http://wiki.mandriva.com/en/Development/Packaging/BuildSystem/Theory"&gt;build system theory
    page&lt;/a&gt;,
    but it seems to be largely a hodgepodge of shell scripts and
    cronjobs, and is likely not a candidate for use by anyone other than
    its&amp;nbsp;designers.&lt;/li&gt;
&lt;li&gt;Argeo provides the &lt;a href="https://www.argeo.org/wiki/SLC"&gt;&lt;span class="caps"&gt;SLC&lt;/span&gt; framework&lt;/a&gt;
    which has a &amp;#8220;&lt;span class="caps"&gt;RPM&lt;/span&gt; Factory&amp;#8221; component, but I can&amp;#8217;t seem to find much
    more than a wiki page, and can&amp;#8217;t tell if it&amp;#8217;s a build automation
    system or just handles mocking packages and putting them in a repo
    on a single&amp;nbsp;host.&lt;/li&gt;
&lt;li&gt;Dag Wieers&amp;#8217; repositories use (or used) a set of python scripts
    called &lt;a href="http://dag.wieers.com/home-made/dar/"&gt;&lt;span class="caps"&gt;DAR&lt;/span&gt;, &amp;#8220;Dynamic Apt Repository
    builder&amp;#8221;&lt;/a&gt;. They&amp;#8217;re on
    &lt;a href="https://github.com/dagwieers/dar"&gt;github&lt;/a&gt; but are listed as &amp;#8220;old&amp;#8221;
    and haven&amp;#8217;t been updated in at least 2 years. The features sound
    quite interesting, and though it&amp;#8217;s based on the Apt repo format, it
    might provide some good ideas for implementing a similar&amp;nbsp;system.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Update four months later:&lt;/strong&gt; I&amp;#8217;ve yet to find a build system that meets
my requirements above. For the moment I&amp;#8217;m only managing \~20 packages,
so my &amp;#8220;build system&amp;#8221; is a single shell script that reads in some
environment variables and runs through using
&lt;a href="http://fedoraproject.org/wiki/Projects/Mock"&gt;mock&lt;/a&gt; to build them in the
correct order (including pushing the finished RPMs back into the local
repository that mock reads from) and then pushing the finished packages
to our internal repository. Maybe when I have some spare time, I&amp;#8217;ll
consider a project to either make a slightly better (but simple) &lt;span class="caps"&gt;RPM&lt;/span&gt;
build system based on Python, or get our
&lt;a href="http://jenkins-ci.org/"&gt;Jenkins&lt;/a&gt; install to handle this for&amp;nbsp;me.&lt;/p&gt;</summary><category term="build"></category><category term="linux"></category><category term="nodejs"></category><category term="package"></category><category term="packaging"></category><category term="repository"></category><category term="rpm"></category><category term="rpmbuild"></category><category term="software"></category><category term="sysadmin"></category><category term="yum"></category></entry><entry><title>Creating RPMs from Perl CPAN Modules</title><link href="http://blog.jasonantman.com/2012/05/creating-rpms-from-perl-cpan-modules/" rel="alternate"></link><updated>2012-05-15T15:01:00-04:00</updated><author><name>admin</name></author><id>tag:blog.jasonantman.com,2012-05-15:2012/05/creating-rpms-from-perl-cpan-modules/</id><summary type="html">&lt;p&gt;I try my absolute best to always install software on my Linux boxes as
&lt;a href="http://en.wikipedia.org/wiki/RPM_Package_Manager"&gt;&lt;span class="caps"&gt;RPM&lt;/span&gt;&lt;/a&gt;s, installed
through &lt;a href="http://yum.baseurl.org/"&gt;Yum&lt;/a&gt; (yes, I use
&lt;a href="http://www.centos.org"&gt;CentOS&lt;/a&gt; on servers and
&lt;a href="http://fedoraproject.org/"&gt;Fedora&lt;/a&gt; on my desktops/laptops). Not only is
this more-or-less required to sanely manage configuration through
Puppet, but it also lets me recreate a machine, or install dependencies
for something, in one simple command line. Unfortunately, I run quite a
bit of Perl code, and there are a lot of &lt;a href="http://www.cpan.org/"&gt;&lt;span class="caps"&gt;CPAN&lt;/span&gt;&lt;/a&gt;
Perl modules that aren&amp;#8217;t in any of the usual CentOS/Fedora&amp;nbsp;repositories.&lt;/p&gt;
&lt;p&gt;Enter cpan2rpm: a Perl script that, in its simplest invocation,
downloads a specified &lt;span class="caps"&gt;CPAN&lt;/span&gt; module and automatically builds RPMs and
SRPMs for it. The &lt;a href="http://perl.arix.com/cpan2rpm/"&gt;original version&lt;/a&gt; by
&lt;a href="http://www.arix.com/ec/"&gt;Erick Calder&lt;/a&gt; hasn&amp;#8217;t been touched since 2005,
but there&amp;#8217;s &lt;a href="http://www.mediaburst.co.uk/blog/creating-perl-module-rpms/"&gt;a newer version from
Mediaburst&lt;/a&gt;,
&lt;a href="http://www2.mbstatic.co.uk/wp-content/uploads/2009/09/cpan2rpmmb"&gt;cpan2rpmmb&lt;/a&gt;,
that seems to incorporate some nice improvements and worked quite well
for&amp;nbsp;me.&lt;/p&gt;</summary><category term="cpan"></category><category term="cpan2rpm"></category><category term="perl"></category><category term="rpm"></category><category term="yum"></category></entry></feed>